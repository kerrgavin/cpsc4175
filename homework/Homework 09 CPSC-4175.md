# Homework 9
## Gavin Kerr

1. I think changes in the requirements alter the process more than human error. It makes sense to me, that with rapidly changing consumer tastes, that changes in requirements would be quite common place.

2. It means that the software had many versions that were improved upon, one after the other, but that there was not a standard order of importance in which the different aspects were completed.

3. When I was younger, I use to do pine wood derbies. I had to make the cars out of a block of wood and there were a set of basic steps that needed to be taken to create a car. Each year, though, I would try to improve the original design. Maybe I would place the weights in a different area or I would sand the wheels for better grip. 

4. The requirements workflow should continue through all the iterations in order to maintain the specifications set by the client. A situation could occur in which the requirements need to change later. Testing should start in the second iteration in order to give the other phases the opprotunity to work throughly. 

5. I would explain that the student take a basic programming assignment and group the different graded parts in order of importance. Then I would tell them to complete the assignment in that order. After the have created a functioning solution that meets the assignment, I would tell then to go back and do the process over but try to improve the solution.

6. I understand this to be true, because a lack of documentation is a dangerous situation. Personally, I would have to start making sure that I document all my code before I can consider it to be complete.

7. While the Code-and-Fix Life-Cycle Model approximates what I do now, I think the Iterative-and-incremental Life-Cycle Model would be the one that I would be most comfortable with. I just makes logical sense to me, and I can see a lot of examples of software I utilize where they use this type of model.

8. I found this paper to be quite helpful and I am planning to save a copy for reference. While I have taken Discrete math before, the content in this paper made more sense to me than how the professor chose to teach the class. Additionally, I was able to relate the mathematical notation to programming standards. While I'm not as well versed in functional languages, which translate better to mathematical notation, I can still see how this relates to an Object Oriented Language like JAVA or C#. I'll have to work with some practice problems in order to fully grasp all the concepts outlined.