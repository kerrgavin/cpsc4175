# Homework 2 CPSC-4175
## Gavin Kerr

1. The first step in creating a piece of software should be listing the requirements in extensive detail. While this is the first step, this step may be completed multiple times if requirements change or update.
2. Discovering what the client needs could be as simple as listing the requirements given by the client themselves. However, it is all to common that the client doesn't fully understand what they need as they may have miss read the situation. Subsequently, the premise for the software is completely wrong. This is different from discovering what the software should do in that there is a clear translation along technical terms. For instance, if the client needs an application for transfering money, then there are many underlying problems that have to be solved that do not involve the concern of the client .
3. I comes from the fact that software engineering is not a "one size fits all" sort of profession. While there are models we can follow in developing software, there is no one best model and a lot of consideration has to be taken.
4. Techniques:
	- Interviewing-this can backfire in a big way if the interview is unstructured or that the information gained uses unspecific language
	- Questionnaire-the questionnaire could not go over enough information and it is impossible for a question to be asked in response to the questionnaire for clarification
	- Forms-this can be very effective but a lot of important information can get lost in the volume of unimportant information
5. Requirements are dynamic in the sense that they are never set in stone. The business will grow or shrink, and with that comes changes to the software. For instance, if a company in the U.S. begin to have dealing in Canada, then the software has to be updated to deal with Canada specific attributes.
6. Functional requirements are the actions that the software needs to perform while the nonfunctional requirements are the attributes of the software. Of course nonfunctional requirements exist, they include operation speed and reliability.
7. It is referred to as structual analysis in the book and it is a nine-step technique to analyze the needs of the client. It starts with determining the logical data flow and ends with the hardware requirements. The case study in chapter 11 utilizes a use-case model for the development, which models the interaction between the software product and the users. The underlying difference is the that the latter shifts the focus immediatly onto software operation while the former maintains focus on the data flow.
8. When one prototypes, the goal is to make a somewhat infantile version of the final product. But this can cause problems in which one encounters issues out of order or issues that only pop up because of the lack of functionality. If one becomes bogged down by this, then the project suffers.
9. Team one is doing a better job, in my opinion, because their software will suffer the least from changes. Now I only have this opinion because of my assumtion that the requirements are changing so infrequently because they did an adequate job of creating them in the first place. 
10. I would say that this is becuase we have gotten very good at catching error in code or malfunctioning hardware, but we still have issues when it comes to effectively listing requirements. This doesn't necessarily mean it is totally the development teams fault, as requirements can change, but we still don't have a sure fire way of dealing with that situation. 