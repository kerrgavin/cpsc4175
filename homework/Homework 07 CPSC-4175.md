# Homework 7
## Gavin Kerr

1. The software should be continuously tested. Lets say that the software gets tested at the end of each phase. In that senario, it would be very costly if an early desin element didn't fit correctly and other elements had to be change because of it. If there is continuous testing, then both major and minor errors can be caught and fixed early.

2. Verification is process of determining whether a workflow has been correctly carried out while validation is the instensive evaluation process that takes place just before the product is delivered to the client. They differ in what they are testing. Verification checks the workflow while validation checks the specifications.

3. Non-execution based testing is done without running test cases while execution based testing does use test cases. In the first, one can do such tests as reading the acctual code or analyze the code mathematically, which can yeild as much information as execution based. With the latter, one creates execuatable test cases that allow for the examination of example output. 

4. In relation to software, "quality" is the extent to which the product satisfies its specifications. In the phrase "software quality assurance", there is an attempt made, throughout the software development process, to assure that the specifications are being met.

5. Well, the different groups have very different jobs and goals. At a basic level, the implementors don't want to break their software, they want the software to work properly. The testers on the other hand, only want the code to break. In a practical sense, it is best for each group to have a seperate task. If they both became responsible for confilicting tasks, then their perfomance would be impacted. 

6. It appears that correctness proofs rely on mathematical proofs to confirm that a piece of software has been built correctly. As stated before, execution testing is making use of test cases and comparing the given output to the expected output. I wouldn't say better, but I would say that execution testing isn't as costly. The correctness proofs require a higher level of math skill and time. Execution testing is easier to perform in this sense and more widely available individuals with lower math skills.

7. I thought the anecdote at the beginning of the article was very effective at getting the initial point across. Honestly, I was shocked at most of the information presented in the article. I always assumed that, in the industry, software engineering had been reduced to a science with tried and tested proceedures. I suppose I should have known this, as the software I use everyday has failed me on multiple occasions when there was seemingly no cause. I anticipate that there will be a lot of change when it comes to software design while I'm in the industry.

8. I think I will be one of the long list of individuals that design software that will have to invoate new methods of design so that better software can be produced. I honestly don't believe that a software apocolypse will happen, but I do feel like the consumers on mass will become more involved and expect higher quality.